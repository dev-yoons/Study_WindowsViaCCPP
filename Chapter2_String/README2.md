# Chapter2. 문자와 문자열로 작업하기

* 버퍼 오버런 에러는 보안 취약점을 공격하는 주요 방법이다.
* 이 챕터는 C 런타임 라이브러리에서 제공하는 새로운 함수에 대해 다루며, 이 함수를 사용하면 문자열 사용 시 발생 가능한 버퍼 오버런을 미연에 방지할 수 있다.
* 항상 유니코드 문자와 새로운 안전 문자열 함수를 이용하여 개발할 것. 이렇게 함으로써 애플리케이션의 수행성능을 향상시키고 로컬라이제이션을 좀 더 쉽게 할 수 있다. COM이나 닷넷 프레임워크와의 상호운용에도 도움이 된다.
---------------------
### Section 01. 문자 인코딩
* 기존에는 문자열을 0으로 끝나는 1바이트 문자의 집합으로 생각하였고, strlen을 호출하면 1바이트 ANSI 문자로 구성된 집합 내에 포함된 문자의 개수를 반환하였다.
* 하지만 많은 문자들이 1바이트로 나타낼 수 있는 256가지의 경우의 수를 초과한다.
* 윈도우 비스타는 유니코드 문자를 UTF-16으로 인코딩한다. UTF-16은 각 문자를 2바이트로 구성한다. 
* 닷넷 프레임워크의 경우 모든 문자와 문자열을 UTF-16으로 인코딩한다.

### Section 02. ANSI 문자와 유니코드 문자 그리고 문자열 자료형
* C언어의 char 자료형은 8비트의 ANSI 문자를 표현하기 위해 존재하며, 기본적으로 문자열은 8비트 char 문자 자료형의 배열로 다루어진다.
* 최근의 마이크로소프트의 C/C++ 컴파일러는 16비트 유니코드를 표현하기 위한 wchar_t 자료형을 내장 자료형으로 처리할 수 있는 기능이 추가되었다. 
* 유니코드 문자와 유니코드 문자열은 다음과 같이 선언한다.
```C++
    wchar_t c = L'A'
    wchar_t szBuffer[100] = L"A String";
```
* 문자열 앞의 대문자 L은 컴파일러가 문자열을 유니코드로 다루도록 한다. 
* 마이크로소프트 윈도우 팀은 C언어의 자료형으로부터 윈도우 자료형을 구분 짓기 위해 WinNT.h 헤더파일에 다음과 같이 자료형을 정의한다.
```C++
typedef char CHAR;
typedef wchar_t WCHAR;
```
* 편의를 위해 문자와 문자열을 가리키는 포인터 자료형에 대해서도 정의한다.
```C++
typedef CHAR *PCHAR;
typedef CHAR *PSTR;
typedef CONST CHAR *PCSTR;

typedef WCHAR *PWCHAR;
typedef WCHAR *PWSTR;
typedef CONST WCHAR *PCWSTR;
```
* 다음과 같은 매크로 또한 정의되어 있다.
```C++
#ifdef UNICODE

typedef WCHAR TCHAR, *PTCHAR, PTSTR;
typedef CONST WCHAR *PCTSTR;
#define __TEXT(quote) L##quote

#else

typedef CHAR TCHAR, *PTCHAR, PTSTR;
typedef CONST CHAR *PCTSTR;
#define __TEXT(quote) quote

#endif

#define TEXT(quote) __TEXT(quote)
```

* 위의 TEXT 매크로를 사용하여 문자를 표기한다면, UNICODE가 정의되어 있으면 16비트 문자, 그렇지 않으면 8비트 문자로 표현하게 된다.

### Section 03. 윈도우 내의 유니코드 함수와 ANSI 함수
* 윈도우 NT 이후의 모든 윈도우 버전은 유니코드를 바탕으로 작성되었다. 따라서 텍스트를 출력하고 문자열을 다루는 것과 같은 핵심 함수들은 모두 유니코드 문자열을 요구한다. 만일 윈도우 함수에게 ANSI문자열을 전달하면, 호출된 함수는 문자열을 유니코드로 변경하여 운영체제에 전달한다. (반환도 마찬가지) 변경 과정은 개발자에게 숨겨져서 제공되지만 시간과 메모리의 낭비는 피할 수 없다.

* 윈도우는 문자열 인자를 가지는 함수를 제공해야할 때 동일한 함수를 두 가지 버전 (유니코드 문자열을 인자로 취하는 함수, ANSI 문자열을 인자로 취하는 함수)이 제공된다.

* 함수명 끝에 W가 추가되어 있으면 주로 유니코드 문자열을 인자로 취하는 버전이라고 볼 수 있다. 유니코드 문자는 8비트 길이보다 긴 16비트 길이를 가지고 있기 때문에 종종 Wide Character라고 불리기 때문이다. 함수명 끝에 A가 추가되어 있으면 ANSI 문자열을 인자로 취하는 버전이라고 볼 수 있다.

* 하지만 보통의 경우 매크로로 정의되어 있으므로 크게 신경 쓸 필요는 없다.
* 그럼에도 불구하고, ANSI 문자열을 사용할 경우, 유니코드 문자열로 변경하는 단계를 추가적으로 수행해야하므로 처음부터 유니코드를 사용하도록 개발하는 것이 효율적이다.

* WinExec, OpenFile 과 같은 몇몇 윈도우 API들은 16비트 윈도우와의 호환성만 유지되고 있기 때문에 인자로 ANSI 문자열만을 지원한다. 이러한 함수는 사용하지 말아야한다.
* 마이크로소프트는 16비트 윈도우의 COM을 Win32로 포팅할 때 COM 인터페이스를 통해 문자열을 전달하는 경우 유니코드 문자열만을 사용하도록 하였다. 따라서 유니코드를 사용하면 COM 컴포넌트와도 좀 더 쉽게 상호운용될 수 있다.

* 리소스 컴파일러가 리소스를 컴파일하면 binary 파일이 생성된다. 이 파일 내의 문자열은 항상 유니코드 문자열로 구성된다.

### Section 04. C 런타임 라이브러리 내의 유니코드 함수와 ANSI 함수
* C 런타임 라이브러리도 윈도우 함수와 마찬가지로 ANSI 문자 함수와 유니코드 문자 함수를 세트로 제공한다. 하지만 윈도우 함수와는 다르게 ANSI 함수는 유니코드로의 변경을 수행하지 않고, 잘 동작한다.
* 대표적으로 ANSI 문자열의 길이를 반환하는 strlen 함수와 유니코드 문자열의 길이를 반환하는 wcslen 함수가 있다. TChar.h 헤더 파일에 있는 _tcslen 을 사용하는 것이 좋다.

### Section 05. C 런타임 라이브러리 내의 안전 문자열 함수
* 문자열을 다루는 함수는 메모리 관련 문제의 위험에 노출되어 있다.
```C++
WCHAR szBuffer[3] = L"";
wcscpy(szBuffer, L"abc"); // 3문자를 담을 수 있는 공간에 4문자를 복사하여 메모리를 깨뜨리는 문제가 발생 (종결문자(0) 포함)
```
* strcpy와 wcscpy 함수 둘 다 버퍼의 최대 크기를 인자로 받지 않기 때문에 메모리에 문제가 생겨도 에러를 보고받을 수 없다. 따라서 wcscat과 같은 새로운 함수로 안전한 코드를 사용하는 것이 좋다.

    #### 1) 새로운 안전 문자열 함수
    * StrSafe.h 헤더 파일은 C 런타임 라이브러리에 포함되어 있는 _tcscpy 매크로와 같은 기존의 문자열 처리 함수를 사용할 때 더 이상 사용되지 않는 함수라는 경고를 나타낼 수 있도록 설정되어 있다.
    * StrSafe.h 의 include 구문은 다른 include 구문보다 반드시 뒤쪽에 위치되어야 한다.
    * _tcscpy 와 같은 기존 함수에 동일한 이름에 _s가 붙은 안전 문자열 함수가 제공되는데, 이 함수들은 버퍼의 크기(문자 개수)도 인자로 전달되도록 정의되어 있다.
    * 문자의 개수는 _countof 매크로를 사용해 쉽게 계산 가능하다.
    * 안전 함수는 가장 먼저 인자의 유효성을 검증하고, 검증이 실패하면 스레드 지역 저장소 변수인 errno에 에러 코드를 설정하고 errno_t 형 값을 반환한다.
    * 안전 문자열 함수를 사용할 때 반환되는 errno_t 값을 확인하여 S_OK 가 반환되면 함수가 성공한 것이다. 다른 값은 errno.h에 정의되어 있다.

    #### 2) 문자열 조작을 수행하는 동안 좀 더 많은 제거를 수행할 수 있도록 하는 방법

    * C 런타임 라이브러리의 새로운 함수들은 어떤 값으로 문자열을 채울지, 문자열 잘림을 어떻게 처리할지를 세부적으로 지정할 수 있다.
    ```C++
    HRESULT StringCchCat(PTSTR pszDest, size_t cchDest, PCTSTR pszSrc);
    ```
    * 함수명에 Cch (Count of characters) 를 포함하고 있을 경우 문자의 개수를 의미하여 _countof 매크로를 이용하면 적절한 값을 전달 가능하다. 
    * 함수명에 Cb (Count of bytes) 를 포함하고 있는 경우 인자로 바이트 수를 요구함을 의미하여 sizeof 연산자를 이용하면 적절한 값을 전달가능하다.