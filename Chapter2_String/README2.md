# Chapter2. 문자와 문자열로 작업하기

* 버퍼 오버런 에러는 보안 취약점을 공격하는 주요 방법이다.
* 이 챕터는 C 런타임 라이브러리에서 제공하는 새로운 함수에 대해 다루며, 이 함수를 사용하면 문자열 사용 시 발생 가능한 버퍼 오버런을 미연에 방지할 수 있다.
* 항상 유니코드 문자와 새로운 안전 문자열 함수를 이용하여 개발할 것. 이렇게 함으로써 애플리케이션의 수행성능을 향상시키고 로컬라이제이션을 좀 더 쉽게 할 수 있다. COM이나 닷넷 프레임워크와의 상호운용에도 도움이 된다.
---------------------
### Section 01. 문자 인코딩
* 기존에는 문자열을 0으로 끝나는 1바이트 문자의 집합으로 생각하였고, strlen을 호출하면 1바이트 ANSI 문자로 구성된 집합 내에 포함된 문자의 개수를 반환하였다.
* 하지만 많은 문자들이 1바이트로 나타낼 수 있는 256가지의 경우의 수를 초과한다.
* 윈도우 비스타는 유니코드 문자를 UTF-16으로 인코딩한다. UTF-16은 각 문자를 2바이트로 구성한다. 
* 닷넷 프레임워크의 경우 모든 문자와 문자열을 UTF-16으로 인코딩한다.

### Section 02. ANSI 문자와 유니코드 문자 그리고 문자열 자료형
* C언어의 char 자료형은 8비트의 ANSI 문자를 표현하기 위해 존재하며, 기본적으로 문자열은 8비트 char 문자 자료형의 배열로 다루어진다.
* 최근의 마이크로소프트의 C/C++ 컴파일러는 16비트 유니코드를 표현하기 위한 wchar_t 자료형을 내장 자료형으로 처리할 수 있는 기능이 추가되었다. 
* 유니코드 문자와 유니코드 문자열은 다음과 같이 선언한다.
```C++
    wchar_t c = L'A'
    wchar_t szBuffer[100] = L"A String";
```
* 문자열 앞의 대문자 L은 컴파일러가 문자열을 유니코드로 다루도록 한다. 
* 마이크로소프트 윈도우 팀은 C언어의 자료형으로부터 윈도우 자료형을 구분 짓기 위해 WinNT.h 헤더파일에 다음과 같이 자료형을 정의한다.
```C++
typedef char CHAR;
typedef wchar_t WCHAR;
```
* 편의를 위해 문자와 문자열을 가리키는 포인터 자료형에 대해서도 정의한다.
```C++
typedef CHAR *PCHAR;
typedef CHAR *PSTR;
typedef CONST CHAR *PCSTR;

typedef WCHAR *PWCHAR;
typedef WCHAR *PWSTR;
typedef CONST WCHAR *PCWSTR;
```
* 다음과 같은 매크로 또한 정의되어 있다.
```C++
#ifdef UNICODE

typedef WCHAR TCHAR, *PTCHAR, PTSTR;
typedef CONST WCHAR *PCTSTR;
#define __TEXT(quote) L##quote

#else

typedef CHAR TCHAR, *PTCHAR, PTSTR;
typedef CONST CHAR *PCTSTR;
#define __TEXT(quote) quote

#endif

#define TEXT(quote) __TEXT(quote)
```

* 위의 TEXT 매크로를 사용하여 문자를 표기한다면, UNICODE가 정의되어 있으면 16비트 문자, 그렇지 않으면 8비트 문자로 표현하게 된다.

### Section 03. 윈도우 내의 유니코드 함수와 ANSI 함수
* 윈도우 NT 이후의 모든 윈도우 버전은 유니코드를 바탕으로 작성되었다. 따라서 텍스트를 출력하고 문자열을 다루는 것과 같은 핵심 함수들은 모두 유니코드 문자열을 요구한다. 만일 윈도우 함수에게 ANSI문자열을 전달하면, 호출된 함수는 문자열을 유니코드로 변경하여 운영체제에 전달한다. (반환도 마찬가지) 변경 과정은 개발자에게 숨겨져서 제공되지만 시간과 메모리의 낭비는 피할 수 없다.

* 윈도우는 문자열 인자를 가지는 함수를 제공해야할 때 동일한 함수를 두 가지 버전 (유니코드 문자열을 인자로 취하는 함수, ANSI 문자열을 인자로 취하는 함수)이 제공된다.

* 함수명 끝에 W가 추가되어 있으면 주로 유니코드 문자열을 인자로 취하는 버전이라고 볼 수 있다. 유니코드 문자는 8비트 길이보다 긴 16비트 길이를 가지고 있기 때문에 종종 Wide Character라고 불리기 때문이다. 함수명 끝에 A가 추가되어 있으면 ANSI 문자열을 인자로 취하는 버전이라고 볼 수 있다.

* 하지만 보통의 경우 매크로로 정의되어 있으므로 크게 신경 쓸 필요는 없다.
* 그럼에도 불구하고, ANSI 문자열을 사용할 경우, 유니코드 문자열로 변경하는 단계를 추가적으로 수행해야하므로 처음부터 유니코드를 사용하도록 개발하는 것이 효율적이다.

* WinExec, OpenFile 과 같은 몇몇 윈도우 API들은 16비트 윈도우와의 호환성만 유지되고 있기 때문에 인자로 ANSI 문자열만을 지원한다. 이러한 함수는 사용하지 말아야한다.
* 마이크로소프트는 16비트 윈도우의 COM을 Win32로 포팅할 때 COM 인터페이스를 통해 문자열을 전달하는 경우 유니코드 문자열만을 사용하도록 하였다. 따라서 유니코드를 사용하면 COM 컴포넌트와도 좀 더 쉽게 상호운용될 수 있다.

* 리소스 컴파일러가 리소스를 컴파일하면 binary 파일이 생성된다. 이 파일 내의 문자열은 항상 유니코드 문자열로 구성된다.

### Section 04. C 런타임 라이브러리 내의 유니코드 함수와 ANSI 함수
* C 런타임 라이브러리도 윈도우 함수와 마찬가지로 ANSI 문자 함수와 유니코드 문자 함수를 세트로 제공한다. 하지만 윈도우 함수와는 다르게 ANSI 함수는 유니코드로의 변경을 수행하지 않고, 잘 동작한다.
* 대표적으로 ANSI 문자열의 길이를 반환하는 strlen 함수와 유니코드 문자열의 길이를 반환하는 wcslen 함수가 있다. TChar.h 헤더 파일에 있는 _tcslen 을 사용하는 것이 좋다.

### Section 05. C 런타임 라이브러리 내의 안전 문자열 함수
* 문자열을 다루는 함수는 메모리 관련 문제의 위험에 노출되어 있다.
```C++
WCHAR szBuffer[3] = L"";
wcscpy(szBuffer, L"abc"); // 3문자를 담을 수 있는 공간에 4문자를 복사하여 메모리를 깨뜨리는 문제가 발생 (종결문자(0) 포함)
```
* strcpy와 wcscpy 함수 둘 다 버퍼의 최대 크기를 인자로 받지 않기 때문에 메모리에 문제가 생겨도 에러를 보고받을 수 없다. 따라서 wcscat과 같은 새로운 함수로 안전한 코드를 사용하는 것이 좋다.

    #### 1) 새로운 안전 문자열 함수
    * StrSafe.h 헤더 파일은 C 런타임 라이브러리에 포함되어 있는 _tcscpy 매크로와 같은 기존의 문자열 처리 함수를 사용할 때 더 이상 사용되지 않는 함수라는 경고를 나타낼 수 있도록 설정되어 있다.
    * StrSafe.h 의 include 구문은 다른 include 구문보다 반드시 뒤쪽에 위치되어야 한다.
    * _tcscpy 와 같은 기존 함수에 동일한 이름에 _s가 붙은 안전 문자열 함수가 제공되는데, 이 함수들은 버퍼의 크기(문자 개수)도 인자로 전달되도록 정의되어 있다.
    * 문자의 개수는 _countof 매크로를 사용해 쉽게 계산 가능하다.
    * 안전 함수는 가장 먼저 인자의 유효성을 검증하고, 검증이 실패하면 스레드 지역 저장소 변수인 errno에 에러 코드를 설정하고 errno_t 형 값을 반환한다.
    * 안전 문자열 함수를 사용할 때 반환되는 errno_t 값을 확인하여 S_OK 가 반환되면 함수가 성공한 것이다. 다른 값은 errno.h에 정의되어 있다.

    #### 2) 문자열 조작을 수행하는 동안 좀 더 많은 제거를 수행할 수 있도록 하는 방법

    * C 런타임 라이브러리의 새로운 함수들은 어떤 값으로 문자열을 채울지, 문자열 잘림을 어떻게 처리할지를 세부적으로 지정할 수 있다.
    ```C++
    HRESULT StringCchCat(PTSTR pszDest, size_t cchDest, PCTSTR pszSrc);
    ```
    * 함수명에 Cch (Count of characters) 를 포함하고 있을 경우 문자의 개수를 의미하여 _countof 매크로를 이용하면 적절한 값을 전달 가능하다. 
    *  함수명에 Cb (Count of bytes) 를 포함하고 있는 경우 인자로 바이트 수를 요구함을 의미하여 sizeof 연산자를 이용하면 적절한 값을 전달가능하다.
    ####
    * HRESULT 반환형을 가진 함수는 3가지 값들 중 하나를 반환한다.
      * S_OK : 성공. 복사 대상 버퍼에 원본 문자열이 정상 복사되었으며, "\0"로 문자열이 종결됨
      * STRSAFE_E_INVALID_PARAMETER : 인자 값으로 NULL이 전달됨
      * STRSAFE_E_INSUFFICIENT_BUFFER : 복사 대상 버퍼가 원본 문자열을 담기에 충분하지 않음
    * _s 로 끝나는 안전 문자열 함수와 달리 이 함수들은 버퍼가 충분하지 않을 경우 문자열 잘림이 수행되고 STRSAFE_E_INSUFFICIENT_BUFFER 값이 반환된다.
    * 복사 대상 버퍼가 충분히 크다면 '\0' 이후의 나머지 공간은 0xfd로 채워진다. 앞서 알아본 함수들의 Ex버전을 사용하면 동작의 수행 여부를 결정하거나 사용자지정값으로 남은 공간을 채울 수 있다.
    #### 3) 윈도우의 문자열 함수
    * 윈도우 또한 문자열을 다루는 다양한 함수를 제공한다.
    * 문자열 간의 비교나 정렬 등을 위한 최상의 함수는 CompareString(Ex)와 CompareStringOrdinal 이다.
    ```C++
    int CompareString(
        LCID locale,
        DWORD dwCmdFlags,
        PCTSTR pString1,
        int cch1,
        PCTSTR pString2,
        int cch2
    );
    ```
    * CompareString 함수는 두 개의 문자열을 비교한다. 첫 번째 매개변수로 각 언어별로 고유한 32비트 값인 지역ID (LCID)를 전달한다. 두 번째 매개변수에는 두 문자열의 비교 방법을 조정하는 플래그 값을 전달한다.
    아래는 예시이다.
      * NORM_IGNORECASE : 대소문자를 구분하지 않는다.
      * NORM_IGNORESYMBOLS : 기호를 무시한다.
    * 나머지 네 개의 매개변수에는 두 개의 문자열과 각 문자열을 구성하는 문자의 개수가 전달된다.
    * CompareStringOridnal 을 사용하면 지역 설정을 고려하지 않고 단순히 값에 의한 비교만을 수행한다. 상대적으로 빠르다. 프로그램 내에서만 사용하는 문자열은 최종 사용자에게 보여지지 않는 경우가 많으므로 이 함수를 사용하는 것이 좋다.
### Section 06. 왜 유니코드를 사용하는 것이 좋은가?
  * 다른 나라의 언어로 지역화하기 쉽다.
  * 단일 바이너리 파일로 모든 언어를 지원 가능하다.
  * 코드가 더 빠르게 수행되고 메모리를 적게 사용한다. (ANSI 문자열의 경우 유니코드로 변경하는 데에 메모리를 할당해야함)
  * 윈도우가 제공하는 모든 함수를 쉽게 사용 가능하다.
  * COM, 닷넷 프레임워크와의 상호 운용이 쉽다.
  * 리소스를 쉽게 다룰 수 있다. (리소스 내의 문자열은 유니코드로 유지됨)
### Section 07. 문자와 문자열 작업에 대한 권고사항
  * 문자열을 char 혹은 byte의 배열이 아닌 문자의 배열로 생각하라.
  * 문자나 문자열을 나타낼 때 중립 자료형을 사용하라.
  * 바이트 혹은 바이트를 가리키는 포인터, 데이터 버퍼 등을 표현하려면 명시적인 자료형 (BYTE, PBYTE)을 사용하라.
  * 문자나 문자열 상수 값을 표현할 때 TEXT, _T 매크로를 사용하라. 일관성을 위해 두 개의 매크로를 혼용하면 안 된다.
  * 문자, 문자열 관련 자료형을 애플리케이션 전반에 걸쳐 변경하라.
  * 문자열에 대한 산술적인 계산 부분을 수정하라.
    * 예를 들어 문자의 개수를 알고 있는 경우 메모리 할당은 바이트 단위로 수행해야 하는데, malloc(nCharacters*sizeof(TCHAR)) 와 같은 코드는 기억하기 까다롭다. 따라서 아래와 같은 매크로를 정의 해두는 것이 좋다.
    ```C++
    #define chmalloc(nCharacters) (TCHAR*)malloc(nCharacters*sizeof(TCHAR))
    ```
  * printf 와 같은 함수를 사용하지 말라. 
  * UNICODE와 _UNICODE 심벌은 항상 동시에 정의/해제하라.
  ####
  * 함수 이름이 _s로 끝나거나 StringCch로 시작하는 안전 문자열 함수를 사용하라. 함수 사용 이후에는 문자열 잘림에 대비하라. 
  (문자열 잘림이 발생하지 않도록 하는 것이 더 좋다)
  * 버퍼와 버퍼의 크기를 동시에 인자로 받지 않는 함수는 사용하지도, 만들지도 마라.
  * 컴파일러가 자동적으로 버퍼 오버런을 감지할 수 있도록 /GS, /RTCs 컴파일러 플래그를 활용하라.
  * 사용자의 언어 설정을 고려하지 않을 땐 (파일명, 경로명 등) CompareStringOrdinal을 사용한다. 
  * 사용자의 유저 인터페이스를 구성하는 문자열의 경우는 CompareString(Ex)을 사용한다.
### Section 08. 유니코드 문자열과 ANSI 문자열 사이의 변경
  * 멀티바이트-문자 문자열을 와이드-문자(유니코드) 문자열로 변경하기 위해서는 MultiByteToWideChar 윈도우 함수를 사용한다. 반대로는 WideCharToMultiByte 윈도우 함수를 사용하면 된다.
  * WideCharToMultiByte 함수는 MultiByteToWideChar 함수와 비교하여 2개의 매개변수를 더 필요로 한다. pDefaultChar 매개변수는 와이드 문자가 코드 페이지 내에 적절한 문자가 존재하지 않을 경우에 사용될 문자를 지정한다. pfUsedDefaultChar 매개변수는 BOOL 값을 가리키는 포인터가 전달되어, 변경할 와이드-문자 문자열 중 멀티바이트-문자 문자열로 변경하는 것이 실패한 문자가 있을 경우 TRUE가 전달된다.
  #### 1) ANSI와 유니코드 DLL 함수의 익스포트
  * 유니코드 함수와 ANSI 함수를 둘 다 제공하려면, 먼저 유니코드용 함수를 작성하고 ANSI 문자열을 유니코드로 변경하는 코드를 작성하여 전달하는 방법을 사용할 수 있다.
  * 마지막으로 DLL 파일과 함께 배포되는 헤더 파일에 두 개의 함수 원형을 기록하면 된다.
  ```C++
  BOOL StringReverseW (PWSTR pWideCharStr, DWORD cchLength);
  BOOL StringReverseA (PSTR pMultiByteStr, DWORD cchLength);
  
  #ifdef UNICODE
  #define StringReverse StringReverseW
  #else
  #define StringReverse StringReverseA
  #endif // !UNICODE
  ```
  #### 2) 텍스트가 ANSI인지 유니코드인지 여부를 확인하는 방법
  * 윈도우 노트패드 애플리케이션(메모장)을 사용하여 인코딩을 변환하여 파일을 저장할 수 있다.
  * 텍스트 파일의 경우 그 내용이 어떤 식으로 저장되었는지를 판단할 수 있는 안정적이고 빠른 방법이 없다.
  * WinBase.h 헤더파일 내에 IsTextUnicode 함수가 AdvApi32.dll에 의해 익스포트되어 존재한다. 하지만 이 함수는 확률적인 방법을 활용하여, 잘못된 결과를 반환할 수 있다.
