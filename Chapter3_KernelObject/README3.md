# Chapter3. 커널 오브젝트
* 커널 오브젝트와 그 핸들을 다루는 마이크로소프트 윈도우 애플리케이션 프로그래밍 인터페이스 (API) 에 대한 설명으로부터 시작한다.
### Section 01. 커널 오브젝트란 무엇인가?
* 운영체제는 엑세스 토큰 오브젝트, 이벤트 오브젝트, 파일 오브젝트 등 다양한 형태의 커널 오브젝트를 생성하고 조작한다.
* WinObj를 사용하면 모든 커널 오브젝트 타입을 나열하고 확인해볼 수 있다.
* 이러한 오브젝트들은 다양한 종류의 함수들을 통해 만들어진다. 하지만 함수의 이름에 포함된 오브젝트의 명칭이 반드시 커널 레벨의 오브젝트 이름과 일치하지는 않는다. CreateFileMapping 함수는 Section 오브젝트를 생성한다.
* *각 커널 오브젝트는 커널에 의해 할당된 간단한 메모리 블록이다.** 이 메모리 블록은 커널에 의해서만 접근이 가능한 구조체로 구성되어 있으며, 커널 오브젝트에 대한 세부 정보들을 저장하고 있다.
* 몇몇 값들은 모든 오브젝트 타입에 공통적으로 존재하지만, 대부분의 값들은 각 오브젝트별로 다르다.
* 커널 오브젝트의 데이터 구조체는 커널에 의해서만 접근이 가능하다. 따라서 애플리케이션에서 데이터 구조체가 저장되어 있는 메모리 위치를 직접 접근하여 그 내용을 변경하는 것이 불가능하다. 구조체에 대한 직접적인 접근을 제한하여 마이크로소프트는 이미 개발되어 있는 애플리케이션에 영향을 미치지 않고도 구조체에 내용을 임의로 추가, 삭제, 변경할 수 있다.
* 구조체에 대해 직접 접근하는 대신, 마이크로소트는 구조체의 내용에 접근할 수 있도록 일련의 함수 집합을 제공하고 있어 이를 통해 커널 오브젝트의 내부적인 값에 접근 가능하다.
* 커널 오브젝트를 생성하는 함수를 호출하면 함수는 각 커널 오브젝트를 구분하기 위한 핸들 값을 반환해준다. 핸들 값은 프로세스 내의 모든 스레드에 의해 사용 가능한 값이지만 특별한 의미를 가지고 있지는 않다. 핸들은 다양한 윈도우 함수들의 매개변수로 전달되는데, 운영체제는 매개변수로 전달된 핸들 값을 통해 어떤 커널 오브젝트를 조작하고자 하는지 구분 가능하다.
* 운영체제를 견고하게 하기 위해 핸들 값들은 프로세스 별로 독립적으로 유지된다. 어떤 스레드가 다른 프로세스의 스레드에게 자신의 핸들 값을 전달하면, 이 핸들 값을 이용하여 수행하는 동작은 실패할 수도 있고 더 좋지 않은 결과를 초래할 수도 있다. 이는 각 프로세스별로 독립된 프로세스 핸들 테이블이 존재하고, 동일한 핸들 값이라도 전혀 다른 커널 오브젝트를 참조할 수 있기 때문이다.
  #### 1) 사용 카운트
  * **커널오브젝트는 프로세스가 아니라 커널에 의해 소유된다.**
  * 다시 말해, 만일 프로세스가 특정 함수를 통해 커널 오브젝트를 생성한 후 종료되어도 반드시 생성된 커널 오브젝트가 프로세스와 함께 삭제되는 것은 아니라는 뜻이다. 대부분의 경우 커널 오브젝트는 프로세스와 함께 삭제되지만, 다른 프로세스가 동일 커널 오브젝트를 사용하고 있따면 커널 오브젝트를 사용하는 모든 프로세스가 종료될 때까지 남아있을 수 있다.
  * 각 커널 오브젝트는 내부적으로 사용 카운트 값을 유지하고 있기 때문에 커널은 이 값을 통해 얼마나 많은 프로세스들이 커널 오브젝트를 사용하고 있는지 알 수 있다. 사용 카운트 값이 0이 되면 커널 오브젝트는 삭제된다.
  #### 2) 보안
  * 커널오브젝트는 보안 디스크립터를 통해 보호될 수 있다.
  * 보안 디스크립터는 누가 커널 오브젝트를 소유하고 있으며, 어떤 그룹과 사용자들에 의해 접근되거나 사용될 수 있는지, 혹은 어떤 그룹과 사용자들에 대해 접근이 제한되어 있는지 정보를 가지고 있다.
  * 커널 오브젝트를 생성하는 거의 대부분의 함수들은 SECURITY_ATTRIBUTES 구조체에 대한 포인터를 인자로 받는다.
  * 대부분의 애플리케이션에서는 현재 프로세스의 보안 토큰을 근간으로 하는 기본 보안 디스크립터를 사용하므로, NULL을 전달하면 된다.
  * 물론 SECURITY_ATTRIBUTES 구조체를 할당하고 초기화한 후 구조체의 주소를 넘겨줄 수도 있다.
  ```C++
  typedef struct _SECURITY)ATTRIBUTES {
      DWORD nLength;
      LPVOID lpSecurityDescriptor;
      BOOL bInheritHandle;
  } SECURITY_ATTRIBUTES;
  ```
  * 보안과 관련있는 멤버는 lpSecurityDescriptor 이다.
  ####
  * 이미 존재하는 커널 오브젝트를 이용하려면 어떤 작업을 수행하려 하는지를 알려주어야 한다.
  ```C++
  HANDLE hFileMapping = OpenFileMapping(FILE_MAP_READ, FALSE, TEXT("MyFileMapping"));
  ```
* 위의 코드는 FILE_MAP_READ를 전달하여 이 커널 오브젝트를 이용해서 읽는 동작만을 수행할 것임을 나타내고 있다.
* 이렇게 획득된 핸들을 이용하여  FILE_MAP_READ 이외의 다른 권한이 필요한 API를 호출한다면 접근 거부 에러가 발생한다.
* 알맞은 보안 접근 플래그를 설정할 수 있도록 유의해야한다. 올바른 플래그를 사용하면 다른 윈도우 버전으로의 포팅이 더욱더 간편해진다.
  
### Section 02. 프로세스의 커널 오브젝트 핸들 테이블
* 프로세스가 초기화되면 운영체제는 프로세스를 위해 커널 오브젝트 핸들 테이블을 할당한다.
* 이 핸들 테이블은 유일하게 커널 오브젝트에 의해서만 사용된다.
* 핸들 테이블은 단순한 데이터 구조체의 배열로 이루어져 있으며, 각 데이터 구조체는 커널 오브젝트에 대한 포인터, 액세스 마스크, 플래그로 구성된다.
#### 1) 커널 오브젝트 생성하기
* 프로세스가 최초로 초기화되면 프로세스의 핸들 테이블은 비어 있다.
* 프로세스 내의 스레드가 CreateFileMapping과 같은 함수를 호출하면 커널은 커널 오브젝트를 위한 메모리 블록을 할당하고 초기화한다. 이후 커널은 프로세스의 핸들 테이블을 조사하여 비어 있는 공간을 찾아내 초기화를 수행한다.
* 포인터 멤버는 커널 오브젝트의 자료 구조를 가리키는 내부적인 메모리 주소, 액세스 마스크는 "풀 액세스", 플래그는 "설정" 상태로 초기화된다.
* 커널 오브젝트를 생성하는 모든 함수는 프로세스별로 고유한 핸들 값을 반환하며, 이 값은 프로세스 내의 모든 스레드들에 의해 사용될 수 있다. 이러한 핸들 값을 4로 나누면 (2비트 시프트) 커널 오브젝트에 대한 정보를 저장하고 있는 프로세스 핸들 테이블의 인덱스 값을 얻을 수 있다.
* 커널 오브젝트 핸들을 인자로 취하는 함수를 호출할 땐 항상 Create- 류의 함수를 호출하여 반환된 핸들 값을 전달해야 한다.
* 핸들 값은 프로세스 핸들 테이블의 인덱스 값으로 활용될 수 있기 때문에 프로세스별로 고유한 값이며, 다른 프로세스에 의해 사용될 수 없다.
* 커널 오브젝트를 생성하는 함수가 실패하면 반환되는 핸들 값은 보통 0(NULL) 혹은 -1(INVALID_HANDLE_VALUE) 이다. 반환값의 확인이 필요하다.
#### 2) 커널 오브젝트 삭제하기
* CloseHandle 함수를 호출하여 더 이상 커널 오브젝트를 사용하지 않을 것임을 시스템에게 알려줄 수 있다.
* 이 함수는 핸들 값을 통해 실제 커널 오브젝트에 접근 가능한지 확인하고, 핸들이 유효하면 커널 오브젝트 구조체 내의 사용 카운트 멤버를 감소시킨다.
* CloseHandle 함수는 반환되기 전 프로세스의 핸들 테이블에서 해당 항목을 삭제한다. 따라서 해당 커널 오브젝트에 접근하는 것이 불가능해지지만, 커널 오브젝트 자체는 삭제되었을 수도 아닐 수도 있다. (오브젝트의 사용 카운트가 0이 아닐 수도 있으므로)
* 일반적으로 커널 오브젝트의 핸들 값을 변수에 저장하는데, CloseHandle 함수를 호출한 이후에는 변수 값도 NULL로 초기화하는 것이 좋다.
* CloseHandle을 호출하지 않으면 오브젝트 누수가 발생할 수도 있고 아닐 수도 있다. 프로세스가 계속해서 수행 중이라면 누수 상황이 발생 가능하고, 프로세스가 종료되면 프로세스가 사용하던 모든 리소스를 반환하기 때문에 누수가 발생하지 않는다.
* 누수 발생 여부는 작업 관리자를 통해 쉽게 확인 가능하다.

### Section 03. 프로세스 간 커널 오브젝트 공유
* 서로 다른 프로세스에서 스레드들 간에 커널 오브젝트를 공유해야하는 경우가 있다.
  * 파일-매핑 오브젝트는 단일머신에서 수행되는 두 프로세스 사이에서 데이터 블록을 공유하도록 한다.
  * 메일슬롯과 명명파이프를 이용하면 네트워크로 연결된 서로 다른 머신 사이에서 데이터를 주고 받을 수 있다.
  * 뮤텍스, 세마포어, 이벤트는 서로 다른 프로세스에서 수행되는 스레드 간에 동기화를 수행할 수 있게 해준다. 이를 이용하면 애플리케이션이 특정 작업을 완료했을 때 다른 애플리케이션에게 완료 사실을 통보해 줄 수 있다.
* 커널 오브젝트의 핸들은 프로세스별로 고유하므로 핸들 값을 공유하는 것은 간단하지 않다. 커널 오브젝트를 공유하는 데에는 세 가지 방법이 존재한다.
#### 1) 오브젝트 핸들의 상속을 이용
  * 공유하고자 하는 프로세스들이 부모-자식 관계를 가질 때에만 사용 가능하다.
  * 먼저 페어런트 프로세스가 커널 오브젝트를 생성할 때 이를 가리키는 핸들이 상속될 수 있음을 시스템에 알려준다. 
  (오브젝트가 상속되는 것이 아니다. 오브젝트 핸들이 상속되는 것이다.)
  상속 가능한 핸들을 만들기 위해서는 SECURITY_ATTRIBUTES 구조체를 초기화하고 이렇게 초기화한 값을 Create 함수에 전달해야 한다.
  ```C++
  SECURITY_ATTRIBUTES sa;
  sa.nLength = sizeof(sa);
  sa.lpSecurityDescriptor = NULL;
  sa.bInheritHandle = TRUE; // 상속 가능

  HANDLE hMutex = CreateMutex(&sa, FALSE, NULL);
  ```
 * 프로세스 핸들 테이블의 플래그 값은, bInheritHandle 멤버가 TRUE 일 때 1로 설정된다.
 ####
 * CreateProcess 함수를 통해 자식 프로세스를 생성할 수 있다. bInheritHandles 매개변수에 TRUE를 전달하면 자식 프로세스는 부모 프로세스의 상속 가능한 핸들 값들을 상속한다.
 * 이 커널 오브젝트를 파괴하려면 부모 프로세스와 자식 프로세스 양쪽 모두에서 CloseHandle 함수를 호출해야 한다. 순서는 상관 없다.
 ####
 * 오브젝트 핸들 상속은 자식 프로세스를 생성할 때만 적용이 가능하다.
 * 오브젝트 핸들 상속을 사용했을 때, 자식 프로세스는 어떤 핸들이 상속된 핸들인지 알 수 없다. 따라서 핸들 상속은 자식 프로세스가 어떤 커널 오브젝트에 접근해야하는지 알고 있을 때에 한해서 유용하다.
 * 핸들을 전달하는 가장 일반적인 방법은 명령행 인자를 이용하여 전달하는 것이다. (_stscanf_s를 사용하여 핸들 값을 얻을 수 있다) 
 혹은 프로세스간 통신을 이용해 전달할 수도 있다. 자식 프로세스의 스레드가 생성한 윈도우로 메시지를 센드/포스트하는 방법, 부모 프로세스가 환경변수 블록에 상속한 커널 오브젝트의 핸들 값을 가지고 있는 새로운 환경변수를 추가하는 방법이 있다.
 ##### 핸들플래그를 변경하는 방법
 * 만약 여러 개의 자식 프로세스 중 하나의 프로세스에게만 핸들을 상속하고 싶다면, SetHandleInformation 함수를 이용하여 상속 플래그를 변경할 수 있다.
 * SetHandleInformation을 통해 HANDLE_FLAG_PROTECT_FROM_CLOSE 플래그가 설정된 핸들은 삭제할 수 없게 된다. 이러한 플래그는 자식의 자식 프로세스에게 까지 핸들을 전달해야 하는데 자식 프로세스가 핸들을 닫아버릴 우려가 있을 때 사용 가능하다.
#### 2) 명명된 오브젝트를 사용
 * 모두는 아니지만, 대부분의 커널 오브젝트는 이름을 가질 수 있다.
 ```C++
 HANDLE CreateMutex(
     PSECURITY_ATTRIBUTES psa,
     BOOL bInitialOwner,
     PCTSTR pszName
 );
 ```
*  pszName에 NULL을 전달하면 익명의 커널 오브젝트가 되지만, '\0'으로 끝나는 문자열 주소를 전달하면 오브젝트의 이름을 지정 가능하다.
```C++
// 프로세스 A가 수행하는 코드
HANDLE hMutexProcessA = CreateMutex(NULL, FALSE, TEXT("JeffMutex"));
// 프로세스 B가 수행하는 코드
HANDLE hMutexProcessB = CreateMutex(NULL, FALSE, TEXT("JeffMutex"));
```
* 이러한 코드를 사용하면, 운영체제는 B 프로세스가 오브젝트에 대한 접근 권한을 가지고 있는지 확인하고 B 프로세스의 핸들 테이블 상에 비어 있는 항목을 추가하고 이미 존재하는 커널 오브젝트를 가리키도록 설정한다.
* 만일 오브젝트의 타입이 불일치하거나 접근 권한이 없는 경우 CreateMutex는 실패하고 NULL을 반환하게 된다.
* B 프로세스의 CreateMutex가 성공하면, 새로운 뮤텍스가 생성되는 것이 아닌 기존의 뮤텍스 오브젝트에 접근할 수 있는 B 프로세스의 핸들 값이 생성되는 것이다.
* 주의할 것은, 이름을 통해 공유하는 경우 기존에 존재하는 오브젝트의 핸들을 가져온 것인지 새롭게 명명된 오브젝트의 핸들을 가져온 것인지 확인해야 한다는 것이다. 
GetLastError를 호출했을 때 반환값이 ERROR_ALREADY_EXISTS 라면, 존재하는 오브젝트의 핸들을 가져온 경우이다.
####
* Open~류의 함수는 명명된 오브젝트가 이미 생성되어 있는 경우에 한해서만 활용 가능하다.
```C++
HANDLE OpenMutex(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    PCTSTR pszName // NULL을 사용하면 안 된다. 반드시 '\0'으로 끝나는 문자열이 필요하다.
);
```
* Create~류의 함수는 커널 오브젝트가 존재하지 않으면 새로운 오브젝트를 생성하지만, Open~류의 함수는 실패한다.
##### 터미널 서비스 네임스페이스
* 터미널 서비스를 수행하는 머신은 커널 오브젝트에 대해 다수의 네임 스페이스를 가진다.
* 모든 터미널 서비스 클라이언트 세션에서 접근 가능한 커널 오브젝트를 위한 전역 네임스페이스가 있는데, 이는 주로 서비스 타입의 애플리케이션에 의해 사용된다. 이와는 별도로 각 클라이언트 세션은 자신만의 고유 네임스페이스를 가진다. 이러한 구성으로 인해 두 개 혹은 다수의 세션에서 동일한 애플리케이션이 각기 수행될지라도 서로간에 영향을 미치지 않는다.
* 이러한 시나리오는 서버 머신 뿐만 아니라 리모트 데스크톱과 빠른 사용자 전환에서도 동일하게 적용된다.
####
* 서비스에서 사용되는 명명된 커널 오브젝트는 항상 전역 네임스페이스에 생성된다.
* 터미널 서비스에서 기동되는 애플리케이션은 각 세션별 네임스페이스 내에 명명된 커널 오브젝트를 생성한다. 하지만 앞에 Global을 붙여 전역 네임스페이스 내에 커널 오브젝트를 생성하도록 명시할 수도 있다.
```C++
Handle h = CreateEvent(NULL, FALSE, FALSE, TEXT("Global\\Myname"));
``` 
* 같은 방법으로 Local을 붙여 현재 세션의 네임스페이스 내에 커널 오브젝트를 생성하도록 명시하는 것도 가능하다.

##### 프라이비트 네임스페이스
* 애플리케이션에서 생성한 명명된 커널 오브젝트가 다른 애플리케이션에서 사용하는 오브젝트의 이름과 충돌하지 않기를 원한다면, 사용자 고유의 프라이비트 네임스페이스를 만들어서 사용하면 된다.
* 서버 프로세스는 네임스페이스 이름 자체를 보호하기 위해 바운더리 디스크립터를 생성하고, 이를 통해 프라이비트 네임스페이스를 생성해야 한다.